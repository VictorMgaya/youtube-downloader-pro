import { NextRequest, NextResponse } from 'next/server'
import ytdl from 'ytdl-core'
import play from 'play-dl'

// Ensure this route runs in the Node.js runtime so native modules like ytdl-core work reliably
export const runtime = 'nodejs'

export async function POST(request: NextRequest) {
  try {
    const { url } = await request.json()

    if (!url) {
      return NextResponse.json(
        { error: 'URL is required' },
        { status: 400 }
      )
    }

    // Validate URL and extract video ID
    const extractVideoId = (input: string): string | null => {
      try {
        const u = new URL(input)
        const host = u.hostname.toLowerCase()
        if (host.includes('youtu.be')) {
          return u.pathname.slice(1)
        }
        if (host.includes('youtube.com')) {
          // watch?v=...
          const v = u.searchParams.get('v')
          if (v) return v
          // /shorts/VIDEO_ID or /embed/VIDEO_ID or other path-based IDs
          const parts = u.pathname.split('/').filter(Boolean)
          if (parts.length) {
            return parts[parts.length - 1]
          }
        }
      } catch (e) {
        // not a URL, may already be a video id
      }

      // If the input itself looks like a video ID, return it
      if (/^[a-zA-Z0-9_-]{10,}$/.test(input)) return input
      return null
    }

    const videoId = extractVideoId(url)
    if (!videoId) {
      return NextResponse.json({ error: 'Invalid YouTube URL or video ID' }, { status: 400 })
    }

    // Prefer using play-dl for reliability; fall back to ytdl-core
    let info: any = null
    try {
      const plInfo = await play.video_info(videoId)
      // play-dl returns video details in plInfo.video_details
      if (plInfo && plInfo.video_details) {
        info = {
          videoDetails: {
            title: plInfo.video_details.title,
            description: plInfo.video_details.description,
            thumbnails: plInfo.video_details.thumbnails.map((t: any) => ({ url: t })) ,
            lengthSeconds: plInfo.video_details.durationInSec || plInfo.video_details.duration || 0,
            viewCount: plInfo.video_details.viewCount || '0',
            uploadDate: plInfo.video_details.uploadDate || '',
            author: { name: plInfo.video_details.channel?.name || plInfo.video_details.author || 'Unknown' },
            videoId: plInfo.video_details.id || videoId,
          },
          formats: (plInfo.sources || []).map((s: any) => ({
            itag: s.itag || s.quality_label || s.quality,
            quality: s.quality || s.quality_label,
            qualityLabel: s.quality_label || s.quality,
            mimeType: s.mimeType || s.type,
            container: s.container || (s.mimeType ? s.mimeType.split('/')[1] : undefined),
            hasVideo: !!s.quality_label,
            hasAudio: !!s.audio,
            width: s.width,
            height: s.height,
            bitrate: s.bitrate,
            audioBitrate: s.audioBitrate || s.audio?.bitrate,
            url: s.url || s.source
          }))
        }
      }
    } catch (e) {
      console.warn('play-dl failed to get video info, falling back to ytdl-core', e)
      try {
        info = await ytdl.getInfo(videoId)
      } catch (err) {
        console.error('Both play-dl and ytdl-core failed to extract info', err)
        return NextResponse.json({ error: 'Failed to fetch video information from YouTube' }, { status: 502 })
      }
    }
    
    // Validate info structure
    if (!info || !info.videoDetails) {
      console.error('ytdl.getInfo returned invalid info object', { info })
      return NextResponse.json({ error: 'Failed to retrieve video details from YouTube' }, { status: 502 })
    }

    // Extract video information
    const thumbnails = Array.isArray(info.videoDetails.thumbnails) ? info.videoDetails.thumbnails : []
    const thumbnail = thumbnails.length ? thumbnails[thumbnails.length - 1].url : null

    const videoInfo = {
      title: info.videoDetails.title || 'Unknown title',
      description: info.videoDetails.description || '',
      thumbnail,
      duration: info.videoDetails.lengthSeconds || 0,
      views: info.videoDetails.viewCount || '0',
      uploadDate: info.videoDetails.uploadDate || '',
      author: (info.videoDetails.author && info.videoDetails.author.name) || 'Unknown',
      videoId: info.videoDetails.videoId || videoId,
    }

    // Filter and format available formats
    const formats = info.formats
      .filter(format => format.hasVideo || format.hasAudio)
      .map(format => ({
        itag: format.itag,
        quality: format.quality,
        qualityLabel: format.qualityLabel,
        mimeType: format.mimeType,
        container: format.container,
        hasVideo: format.hasVideo,
        hasAudio: format.hasAudio,
        width: format.width,
        height: format.height,
        bitrate: format.bitrate,
        audioBitrate: format.audioBitrate,
        url: format.url,
      }))
      .sort((a, b) => {
        // Sort by quality for video formats
        if (a.hasVideo && b.hasVideo) {
          return (b.height || 0) - (a.height || 0)
        }
        // Sort by bitrate for audio formats
        if (!a.hasVideo && !b.hasVideo) {
          return (b.audioBitrate || 0) - (a.audioBitrate || 0)
        }
        // Video formats first
        return a.hasVideo ? -1 : 1
      })

    return NextResponse.json({
      videoInfo,
      formats
    })

  } catch (error) {
    console.error('Error fetching video info:', error)
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to fetch video information' },
      { status: 500 }
    )
  }
}